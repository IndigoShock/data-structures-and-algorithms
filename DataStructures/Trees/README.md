## Trees ##

1. Visuals of what it looks like
![TreeImage](assets\BinaryTrees.jpg)
![TreeSearchImage](assets\BinarySearchTrees.jpg)

2. How you implemented it 
For Binary Tree, the root node sit on top. The functionality of it is to traverse through and determine whether the value of the root element is larger or greater than the new node element.
For Binary Search Trees, the root node still sits on top. The functionality is to search and add elements to it based on the Binary tree functionality. If the new node element is greater than the root node, value continues to right until it is less than the root node and continues until there is a null element for it to fall into.

3. What type of uses you would use Binary Trees for (provide 2 examples)
   - "Binary Search Tree - Used in many search applications where data is constantly entering/leaving, such as the map and set objects in many languages' libraries."
   - "Binary Space Partition - Used in almost every 3D video game to determine what objects need to be rendered."

Acknowledgements
[Instructor](Amanda Iverson)
[TA's](Philip Werner and Erik Plyushko)
[Classmates](https://github.com/jcqnly, Jesse Atay and Earl Jay Caoile)

[Real world examples](https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees)